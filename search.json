[{"title":"vue.js长按自定义指令","url":"/2017/10/31/vue-js长按自定义指令/","content":"适用于vue.js的长按指令\n最近的项目一直做的是Android和前端的混编。大致是用一个Android的壳子，套在里边的是通过webview加载的前端页面。前端用的是vue.js。之前有个项目中有长按事件的需求，自己通过js写了一个，但是总觉得在vue里边使用不是很舒服，所以才想着通过自定义指令封装一下。其实运用的思路和我之前的写的js是相同的，长按是通过setTimeOut()来控制实现的。具体如下：\n<pre><code>\n\t/**\n\t * 自定义指令：元素的长按事件\n\t * 使用：\n\t * v-long-click=\"callback\" //在一定时间后执行事件\n\t * v-long-click.continuous=\"callback\" //连续执行事件\n\t */\n\tVue.directive('long-click',{\n\t  bind:function (el,binding) {\n\t    if(typeof binding.value !== 'function'){ //不是方法时给出提示\n\t      console.log(\"-------------\"+binding.value+\"------------\");\n\t    }\n\t    var time = 0;\n\t    const isContinuous = binding.modifiers.continuous; //判断是否为连续执行\n\t    const handlerStart = (e) => { //touchstart 执行事件\n\t      if(isContinuous==true){\n\t        el.longTime1 = setInterval(() => {\n\t          binding.value(e);\n\t        },300);\n\t      }else{\n\t        el.longTime2 = setInterval(() => {\n\t           time++;\n\t           if(time==15){\n\t             binding.value(e);\n\t             window.clearInterval(el.longTime2);\n\t             time=0;\n\t           }\n\t        },100)\n\t      }\n\t    };\n\t    el.__vueLongClick__ = handlerStart;\n\t    const handlerEnd = (e) => { //touchend 执行事件\n\t      if(isContinuous==true){\n\t        window.clearInterval(el.longTime1);\n\t      }else {\n\t        window.clearInterval(el.longTime2);\n\t      }\n\t    };\n\t    el.__vueLongClickOver__ = handlerEnd;\n\t    el.addEventListener('touchstart',handlerStart); //添加事件监听\n\t    el.addEventListener('touchend',handlerEnd);\n\t  },\n\t  unbind:function (el) {\n\t    el.removeEventListener('touchstart');\n\t    el.removeEventListener('touchend');\n\t    el.__vueLongClick__ = null;\n\t    el.__vueLongClickOver__=null;\n\t  }\n\t});\n</code></pre>\n这个指令是通过我在网上查询其他自定义指令的书写方法来写的。分为：长按之后执行某一事件和连续执行某一事件。测试是有效的，如果有不妥的地方，大家可以帮忙指正。当然指令的具体执行间隔时间大家可以自行更改。","tags":["vue.js"]},{"title":"Andrid个推（推送）集成","url":"/2017/10/31/Andrid个推（推送）集成/","content":"Android集成个推（推送）\n项目背景是公司的产品中需要用到推送来从服务器端主动推出，然后app接收，从而完成下一步操作。其实这个功能让app进行循环检测也可以完成，但是这样就造成了以下几个问题：\n1. app和服务器开销过大。\n2. 并不能进行实时监控。\n因为公司以前的产品都在使用个推，所以我也就使用个推了。\n\n----------\n\n个推集成前注意事项：\n1. 根据需求进行操作。在我们的产品中不需要个推的推送界面和其他杂七杂八的推送服务，只是简简单单的主动推出，传递数据。所以我们只需要简单的进行必要的集成和封装就行。\n2. 在集成过程中。注意区分个推版本：2.9.5.0和之前的版本有很大的不一样，在集成过程中要注意区分。\n3. 一定要仔细产看集成文档，必要的时候可以先写个简单的demo。原因就是集成的过程中稍有不注意，就会造成clientId获取不到，进而造成推送获取不到。\n\n----------\n\n具体的集成步骤和方法：\n1. 申请个推账号，创建应用（这些在个推官网按照具体步骤即可）\n2. 添加maven仓库（没有添加会提示找不到依赖）\n\t![](http://docs.getui.com/mobile/android/img/asmv_maven.png)\n3. 添加依赖\n\t![](http://docs.getui.com/mobile/android/img/asmv_dep.png)\n4. gradle配置（在标红色的区域，填写上你自己应用的信息）\n \t![](http://docs.getui.com/mobile/android/img/asmv_param.png)\n5. 创建PushServer（用于接收数据）\n\t<pre><code>\n\tpublic class PushService extends GTIntentService {\n\t    @Override\n\t    public void onReceiveServicePid(Context context, int i) {\n\n\t    }\n\n\t    @Override\n\t    public void onReceiveClientId(Context context, String s) {\n\t\t\t//获取client_id（s 就是client_id的内容）\n\t        Intent intent_onInited = new Intent(WelcomeActivity.ACTION_ONGETUI_INITED);\n\t        intent_onInited.putExtra(\"clientid\",s);\n\t        context.sendBroadcast(intent_onInited);\n\t    }\n\n\t    @Override\n\t    public void onReceiveMessageData(Context context, GTTransmitMessage gtTransmitMessage) {\n\t\t\t//处理个推信息\n\t        byte[] payload = gtTransmitMessage.getPayload();\n\t        if (payload != null) {\n\t            String json = new String(payload); //个推传递过来的数据\n\t            Log.d(\"PushReceiver\", \"receiver payload= \" + json);\n\t            Intent intent_onReceive = new Intent(WelcomeActivity.ACTION_ONGETUI_MSG);\n\t            intent_onReceive.putExtra(\"push_data\",json);\n\t            context.sendBroadcast(intent_onReceive);\n\t        }\n\t    }\n\n\t    @Override\n\t    public void onReceiveOnlineState(Context context, boolean b) {\n\n\t    }\n\n\t    @Override\n\t    public void onReceiveCommandResult(Context context, GTCmdMessage gtCmdMessage) {\n\n\t    \t}\n\t}\n\t</code></pre>\n以上的方法中的内容可以视情况而定。\n6. 创建第三方推送服务\n\t<pre><code>\n\tpublic class PushUtilService extends Service {\n\t    @Override\n\t    public void onCreate() {\n\t        super.onCreate();\n\t        GTServiceManager.getInstance().onCreate(this);\n\t    }\n\n\t    @Override\n\t    public int onStartCommand(Intent intent, int flags, int startId) {\n\t        super.onStartCommand(intent, flags, startId);\n\t        return GTServiceManager.getInstance().onStartCommand(this, intent, flags, startId);\n\t    }\n\n\t    @Override\n\t    public IBinder onBind(Intent intent) {\n\t        return GTServiceManager.getInstance().onBind(intent);\n\t    }\n\n\t    @Override\n\t    public void onDestroy() {\n\t        super.onDestroy();\n\t        GTServiceManager.getInstance().onDestroy();\n\t    }\n\n\t    @Override\n\t    public void onLowMemory() {\n\t        super.onLowMemory();\n\t        GTServiceManager.getInstance().onLowMemory();\n\t    }\n\t}\n\t</code></pre>\n 这个服务类是很有意思的服务了，其中\n![](https://i.imgur.com/cyLLRDf.png)\n这个地方当你写完之后是会报错警告的，但是在个推的官方文档上并没提到。原因是在这里的返回值必须是固定的。但是这个报错警告是不影响你整个个推的。\n另外，这个类还存在一个问题，这个问题到下边使用的时候再讲。\n7.  AndroidManifest.xml文件配置（很关键）\n为什么说这里很关键，是因为在你配置了必要的权限管理并且将上边定义的服务也添加了之后，一定不要忘记添加\n![](https://i.imgur.com/b3RG705.png)\n特别是红框标记的，虽然你在gradle中有配置，但这里一定还要添加上，就像图中添加上即可。\n8. 使用（初始化推送和注册PushServer）:\n使用的时候在onCreate中注册。但是，当我自己写个demo的时候这种方式是可行的，当我集成进入项目，却发现很难初始化成功，于是又在onResume中重新初始化（重复初始化是不会影响个推的，这点在文档上提到过）。另外，我们上边遗留的问题也在这里揭晓。\n\t<pre><code>\n\tPushManager.getInstance().initialize(this.getApplicationContext(), PushUtilService.class);//初始化\n    PushManager.getInstance().registerPushIntentService(this, PushService.class);//注册接收数据服务\n\t</code></pre>\n在我们进行初始化的时候，我们的第二个参数就是我们自定义的推送服务类（也就是文档上说的支持的第三方的推送服务），这个参数如果我们传null的时候，也是可行的，大家可以点到初始化的方法中查看![](https://i.imgur.com/i6hJPXI.png)在传null的时候是会调用个推自己的服务的。再进入个推自己的服务类中我们会发现，和我们自己写的很类似。但是，这里可以传null,不代表这个类不需要写，我在不写的时候，确实出现了一些很奇怪的错误。当然也可能是我没有研究透彻，或者哪里写的不对，所以这个问题，大家还是可以自己探索的。当然我们既然写了，在初始化的时候还是添加上。\n注意：\n![](https://i.imgur.com/FGHtUvp.png)\n自定义的服务类请按照文档上的格式在配置文件中进行配置。\n\n----------\n好了，以上就是本人在集成过程中的步骤和遇到坑。当然可能很多问题还有其他的途径解决，错误的地方希望大家指正。\n","tags":["android"]},{"title":"Android集成阿里云OSS直传","url":"/2017/10/30/Android集成阿里云OSS直传/","content":"首先想说下这个功能的背景，因为最近公司的项目维护升级，需要一个在webview调用照相机，直接拍照上传的功能。为了减少接口和业务服务器压力，所以选择将图片直传到阿里云上，所以自己开始摸索。\n\n先说一下功能实现的步骤和遇到的几个问题：\n1. 在webview中调用照相设备，获取图片。此步骤中的问题如下：\n\t（1）通过什么样的方法进行webview调用照相设备的操作。\n\t（2）在通过照相机照完照片后怎样获取照片。\n\t（3）照片该怎样压缩然后进行上传。\n\t（4）上传后怎样删除保存后的图片。\n2. 通过阿里云进行图片上传。此步骤中的问题如下：\n\t（1）阿里云oss上传服务的集成。\n\t（2）阿里云有两种方式进行上传，该选择哪个？\n\t（3）webview（前端）该怎样和Android进行交互进行上传。\n\n----------\n\n既然存在问题，那我们就开始先解决问题，再进行实际操作：\n\n*通过什么样的方法进行webview调用照相设备的操作*；*在通过照相机照完照片后怎样获取照片*。\n这两个问题为什么放在一起，是因为他们的实现方式是连贯的，在某些地方需要相同的操作。这个两个问题最直观的解决方法，大家可能想到通过input标签进行调用，然后开启照相设备，然后进行图片选择。但是通过这个方法调用照相设备和获取照片是有限制的，就是在你的webview中的setWebChromeClient()方法中重写openFileChooser()方法，但是这里要注意，不同的android版本需要区分开。在我们的项目中需要的是在拍照后直接上传，不需要再进行选择，所以没有采用这种方式。我采取的方法是：通过js，调用android方法，直接打开照相设备（在android中打开照相设备比上述方法简单太多），然后通过指定具体的路径进行图片保存，并且在Android中直接获拿图片路径进行上传（这样获取图片路径的步骤就省了，因为图片路径已经指定）。\n*照片该怎样压缩然后进行上传*。\n这个其实就是图片压缩的问题，由于我们的图片对尺寸不做限制，所以我只进行了图片的质量压缩，方式很简单，将图片转换为bitmap格式，然后进行压缩，这应该是android最常用的压缩方式了。但这里我将图片保存转换时，将图片转换为了webp格式，为什么用这个格式是因为，webp图片的大小很小，占用内存很少，不管是在存的时候，还是在加载的时候都会提高效率，节省资源。这里可以给大家大致举例一下我的图片在转换压缩前后的对比：一张大概在1.4M的png图片，在压缩比为30%的时候，压缩后的图片大小在300k左右（大家没看错，实际的图片大小是比换算的更小），但在转化为webp后，只有60~70k，可以看到差距很明显。\n*上传后怎样删除保存后的图片*。\n为什么要删除，是为了防止设备常年使用，积累过多图片。删除是很简单的，上边已获得了图片路径，所以一般的文件删除即可。但是我想说的是，由于我们上传的图片并不是隐私或者重要的图片，所以我没有进行删除，而是在保存的时候进行了替换，这是一个投机取巧的方式，看大家具体的项目需求。\n*阿里云oss上传服务的集成*。\n这个问题我列出来是因为大家在看阿里云oss安卓直传的部分的时候,并没有写集成方式，所以还是需要按照正常的sdk集成，具体链接为：\n[https://help.aliyun.com/document_detail/32042.htmlspm=5176.doc32043.6.696.vB2P2R](https://help.aliyun.com/document_detail/32042.html?spm=5176.doc32043.6.696.vB2P2R)\n*阿里云有两种方式进行上传，该选择哪个*。\n其实阿里云提供的上传方式大致可以分为两种，一种是直接携带固定的校验参数，一种是通过业务服务器获取动态凭证，为了安全性考虑，我采用的动态获取。\n*webview（前端）该怎样和Android进行交互进行上传*。\n答案很简单，调用通过js和安卓交互。具体的方式实现网上有很多，不在多说。我只说一下难点，我们的webview呈现的页面时通过vue.js这个前端框架编写的。在这里我们在上传开始的时候需要提示上传开始，上传完成后需要提示上传完成。这就要求我们要有事件监听。其实在安卓里我们有很多方式可以实现，比如：广播，EvenBus，接口设计模式……。但是这些不能用于前端中，我们在vue中，使用了$on,$off,$emit这几个指令来组合实现。\n\n\n----------\n具体的实现代码：\n1. 集成oss：\n   ![](https://i.imgur.com/R9lbwmF.png)\n2. 然后根据文档进行方法封装，以下是我封装的方法:\n<pre><code>\n\timport android.content.Context;\n\timport android.support.annotation.NonNull;\n\timport android.util.Log;\n\timport com.alibaba.sdk.android.oss.ClientConfiguration;\n\timport com.alibaba.sdk.android.oss.OSS;\n\timport com.alibaba.sdk.android.oss.OSSClient;\n\timport com.alibaba.sdk.android.oss.callback.OSSCompletedCallback;\n\timport com.alibaba.sdk.android.oss.common.auth.OSSCredentialProvider;\n\timport com.alibaba.sdk.android.oss.common.auth.OSSFederationCredentialProvider;\n\timport com.alibaba.sdk.android.oss.common.auth.OSSFederationToken;\n\timport com.alibaba.sdk.android.oss.internal.OSSAsyncTask;\n\timport com.alibaba.sdk.android.oss.model.PutObjectRequest;\n\timport com.alibaba.sdk.android.oss.model.PutObjectResult;\n\timport com.youhongedu.sx2.tea.v3.bean.UploadBean;\n\timport java.io.File;\n\t//阿里云上传工具类\n\tpublic class OssUploadUtil {\n\t    private static UploadBean mUploadBean;//升级javaBean\n\t    private static OssUploadUtil ossUploadUtil;\n\t    private static Context context;\n\n\t    private OssUploadUtil(Context context, UploadBean uploadBean){\n\t        this.context = context;\n\t        this.mUploadBean = uploadBean;\n\t    }\n\t    public static OssUploadUtil getOssUploadUtil(Context context,UploadBean uploadBean){\n\t        if(ossUploadUtil==null){\n\t            ossUploadUtil = new OssUploadUtil(context,uploadBean);\n\t        }\n\t        return ossUploadUtil;\n\t    }\n\t    // 初始化oss服务\n\t    public OSS initOSS() {\n\t        //使用自己的获取STSToken的类\n\t        OSSCredentialProvider credentialProvider = new STSGetter();\n\t        ClientConfiguration conf = new ClientConfiguration();\n\t        conf.setConnectionTimeout(15 * 1000); // 连接超时，默认15秒\n\t        conf.setSocketTimeout(15 * 1000); // socket超时，默认15秒\n\t        conf.setMaxConcurrentRequest(5); // 最大并发请求书，默认5个\n\t        conf.setMaxErrorRetry(2); // 失败后最大重试次数，默认2次\n\t        Log.e(\"endpoint\",mUploadBean.getEndpoint());\n\t        OSS oss = new OSSClient(context, mUploadBean.getEndpoint(), credentialProvider, conf);\n\t        return oss;\n\t    }\n\t    //上传\n\t    public void asyncPutImage(String object, String localFile, OSS oss,\n\t                              @NonNull final OSSCompletedCallback<PutObjectRequest, PutObjectResult> userCallback) {\n\t        if (object.equals(\"\")) {\n\t            Log.w(\"AsyncPutImage\", \"ObjectNull\");\n\t            return;\n\t        }\n\t        File file = new File(localFile);\n\t        if (!file.exists()) {\n\t            Log.w(\"AsyncPutImage\", \"FileNotExist\");\n\t            Log.w(\"LocalFile\", localFile);\n\t            return;\n\t        }\n\t        Log.e(\"localFile\",localFile+\"-------------\");\n\t        // 构造上传请求\n\t        Log.e(\"bucket\",mUploadBean.getBucket());\n\t        PutObjectRequest put = new PutObjectRequest(mUploadBean.getBucket(), object, localFile);\n\t        OSSAsyncTask task = oss.asyncPutObject(put, userCallback);\n\t    }\n\t    //内部类：获取sts服务（同时携带临时token）\n\t    public class STSGetter extends OSSFederationCredentialProvider {\n\t        public STSGetter() {\n\t        }\n\t        public OSSFederationToken getFederationToken() {\n\t            Log.e(\"Accesskeyid\",mUploadBean.getAccesskeyid()+\"\");\n\t            return new OSSFederationToken(mUploadBean.getAccesskeyid(), mUploadBean.getAccesskeysecret(),\n\t             mUploadBean.getSecuritytoken(), mUploadBean.getExpiration());\n\t        }\n\t    }\n\t}\n3.安卓中调取照相机，在这里我们直接指定存储位置和名称\n<pre><code>\n    //拍照\n      @JavascriptInterface\n      public void take(){\n          Log.e(\"take\",\"点击成功\");\n          Intent cameraIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);//拍照\n          Uri imageUri = Uri.fromFile(new File(Environment.getExternalStorageDirectory(),\"/demo.jpg\"));//直接指定存储位置和名称\n          cameraIntent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);\n          startActivityForResult(cameraIntent,REQUEST_UPLOAD_FILE_CODE);\n      }\n4.获取bitmap图片，方便进行压缩\n<pre><code>\n   //获取bitmap格式\n    public Bitmap getBitmap(String imgPath) {\n       BitmapFactory.Options newOpts = new BitmapFactory.Options();\n       newOpts.inJustDecodeBounds = false;\n       newOpts.inPurgeable = true;\n       newOpts.inInputShareable = true;\n       newOpts.inSampleSize = 1;\n       newOpts.inPreferredConfig = Bitmap.Config.RGB_565;\n       return BitmapFactory.decodeFile(imgPath, newOpts);\n    }\n5.图片压缩处理\n<pre><code>\n   //  图片压缩\n    private void compressPhoto(){\n        Bitmap photo = getBitmap(Environment.getExternalStorageDirectory()+\"/demo.jpg\");\n        FileOutputStream fos =null;\n        try {\n            fos = new FileOutputStream(Environment.getExternalStorageDirectory()+\"/demo.webp\");\n            photo.compress(Bitmap.CompressFormat.WEBP,30,fos); //图片压缩\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }finally{\n            try {\n                fos.flush();\n                fos.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n6.以上就是上传前的准备工作，由于此前封装好的工具类，在真正的上传过程中代码其实很简单\n<pre><code>\n // 在OnActivityResult中处理拍照上传\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (requestCode == REQUEST_UPLOAD_FILE_CODE && resultCode == RESULT_OK) {\n            new Thread(new Runnable() {  //开启子线程防止照相后出现闪出桌面现象\n                @Override\n                public void run() {\n                    compressPhoto();\n                    OssUploadUtil ossUploadUtil = OssUploadUtil.getOssUploadUtil(WelcomeActivity.this,mUploadBean);\n                    OSS oss = ossUploadUtil.initOSS();\n                    ossUploadUtil.asyncPutImage(mUploadBean.getUpload_dir()+mUploadBean.getPhoto_name(),\n                                                Environment.getExternalStorageDirectory()+\"/demo.webp\",oss,\n                                                new OSSCompletedCallback<PutObjectRequest, PutObjectResult>() {\n                        @Override\n                        public void onSuccess(PutObjectRequest request, PutObjectResult result) {\n\t\t\t\t\t\t\t//这里是url的拼接（即图片在阿里云上的访问地址）\n                            String url = \"http://\"+mUploadBean.getBucket()+\".\"+mUploadBean.getEndpoint()+\n                            \"/\"+mUploadBean.getUpload_dir()+mUploadBean.getPhoto_name();\n                            uploadUrl=url;\n                            mUploadBean = null;\n                     \t\t//这里可进行上传后的操作\n                            Log.e(\"success\",\"成功+\"+JSON.toJSONString(request));\n                            Log.e(\"success\",\"成功-\"+result);\n                            Log.e(\"url\",url);\n                        }\n                        @Override\n                        public void onFailure(PutObjectRequest request, ClientException clientException,\n                                              ServiceException serviceException) {\n                            mHandler.sendEmptyMessage(MSG_UNREGECT_ERROR);\n                            mUploadBean = null;\n                            Log.e(\"error\",\"失败1:\"+clientException);\n                            Log.e(\"error\",\"失败2:\"+serviceException);\n                            Log.e(\"error\",\"失败0:\"+JSON.toJSONString(request));\n                        }\n                    });\n                }\n            }).start();\n        }\n    }\n这样整个上传工作都做完了，多说一句，在上传后返回的参数中并不包含图片在外网的访问地址，所以，需要手动拼接提交业务服务器。但是在网上我也看到有其他的获取url的方式，但我可能由于一些操作或者其他问题没有使用成功（并不代表别人的不能使用），所以大家可以自行研究。","tags":["android"]},{"title":"Hello World","url":"/2017/08/17/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]